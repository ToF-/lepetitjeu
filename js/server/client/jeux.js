// Generated by CoffeeScript 1.3.1
(function() {
  var Bomb, Coordinate, KeyboardManager, Player, caseNumber, caseWidth, dropBomb, manageKB, map, myPlayer, paper, players, preparePlayground, socket, tell;

  myPlayer = {};

  players = [];

  paper = {};

  caseWidth = 30;

  caseNumber = 21;

  map = {};

  $(function() {
    paper = Raphael(10, 50, caseWidth * caseNumber, caseWidth * caseNumber);
    socket.emit('new');
    return $(document).keydown(manageKB);
  });

  KeyboardManager = (function() {

    KeyboardManager.name = 'KeyboardManager';

    function KeyboardManager() {}

    KeyboardManager.prototype.key = {
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      space: 32
    };

    KeyboardManager.prototype.keyPress = function(k) {
      switch (k.which) {
        case key.left:
          return tempCoordinate.x -= 1;
        case key.up:
          return tempCoordinate.y -= 1;
        case key.right:
          return tempCoordinate.x += 1;
        case key.down:
          return tempCoordinate.y += 1;
        case key.space:
          return dropBomb();
      }
    };

    return KeyboardManager;

  })();

  Player = function(id, color) {
    this.id = id;
    this.color = color;
    this.coordinate = new Coordinate({
      x: 0,
      y: 0
    });
    this.drawing = {};
    this.updateDrawing = function() {
      this.drawing.attr('cx', this.coordinate.x * caseWidth + caseWidth / 2);
      this.drawing.attr('cy', this.coordinate.y * caseWidth + caseWidth / 2);
      return this;
    };
    this.initialize = function() {
      var circle;
      circle = paper.circle(this.coordinate.x * caseWidth + caseWidth / 2, this.coordinate.y * caseWidth + caseWidth / 2, caseWidth / 2 - 2);
      circle.attr("fill", this.color);
      circle.attr("stroke", "#333");
      return this.drawing = circle;
    };
    return this;
  };

  Coordinate = function(obj) {
    this.x = obj.x;
    this.y = obj.y;
    this.areEqual = function(coordinate) {
      return this.x === coordinate.x && this.y === coordinate.y;
    };
    return this;
  };

  manageKB = function(k) {
    var tempCoordinate;
    tempCoordinate = new Coordinate(myPlayer.coordinate);
    if (k.which === key.space) {
      return dropBomb();
    } else {
      switch (k.which) {
        case key.left:
          tempCoordinate.x -= 1;
          break;
        case key.up:
          tempCoordinate.y -= 1;
          break;
        case key.right:
          tempCoordinate.x += 1;
          break;
        case key.down:
          tempCoordinate.y += 1;
          break;
        case key.space:
          dropBomb();
          break;
        default:
          console.log('nop ' + k.which);
      }
      if (tempCoordinate.x < 0) {
        tempCoordinate.x = 0;
      }
      if (tempCoordinate.x > (caseNumber - 1)) {
        tempCoordinate.x = caseNumber - 1;
      }
      if (tempCoordinate.y < 0) {
        tempCoordinate.y = 0;
      }
      if (tempCoordinate.y > (caseNumber - 1)) {
        tempCoordinate.y = caseNumber - 1;
      }
      console.log(map[tempCoordinate.x][tempCoordinate.y], tempCoordinate.x, tempCoordinate.y);
      if ((players.filter(function(element) {
        return element.id !== myPlayer.id && element.coordinate.areEqual(tempCoordinate);
      })).length === 0 && map[tempCoordinate.x][tempCoordinate.y] === 0) {
        myPlayer.coordinate = tempCoordinate;
        myPlayer.updateDrawing();
      } else {
        console.log('colision');
      }
      return tell();
    }
  };

  tell = function() {
    return socket.emit('move', {
      coordinate: myPlayer.coordinate,
      id: myPlayer.id,
      color: myPlayer.color
    });
  };

  dropBomb = function() {
    console.log('dropBomb');
    return socket.emit('dropBomb', {
      coordinate: myPlayer.coordinate
    });
  };

  preparePlayground = function(map) {
    var color, drawCase, item, row, x, y, _i, _j, _len, _len1, _results, _step, _step1;
    drawCase = function(x, y, color) {
      var paperCase;
      paperCase = paper.rect(x * caseWidth, y * caseWidth, caseWidth, caseWidth);
      if (color) {
        paperCase.attr('fill', '#888');
      } else {
        paperCase.attr('fill', '#eee');
      }
      return paperCase.attr("stroke", "#fff");
    };
    console.log("start");
    y = 0;
    _results = [];
    for (_i = 0, _len = map.length, _step = 1; _i < _len; _i += _step) {
      row = map[_i];
      x = 0;
      for (_j = 0, _len1 = row.length, _step1 = 1; _j < _len1; _j += _step1) {
        item = row[_j];
        color = item === 1 ? true : false;
        console.log(x, y, color);
        drawCase(x, y, color);
        x++;
      }
      _results.push(y++);
    }
    return _results;
  };

  Bomb = function(coord) {
    return paper.rect(coord.x * caseWidth, coord.y * caseWidth, caseWidth, caseWidth, 10).attr("fill", "#f00");
  };

  socket = io.connect(window.location.href);

  socket.on('move', function(data) {
    var currentPlayer, player, playerToMove;
    playerToMove = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = players.length; _i < _len; _i++) {
        player = players[_i];
        if (player.id === data.id) {
          _results.push(player);
        }
      }
      return _results;
    })();
    if (playerToMove.length === 0) {
      currentPlayer = new Player(data.id, data.color);
      currentPlayer.initialize();
      players.push(currentPlayer);
    } else {
      currentPlayer = playerToMove[0];
    }
    currentPlayer.coordinate = new Coordinate(data.coordinate);
    return currentPlayer.updateDrawing();
  });

  socket.on('new', function(data) {
    var playerToAdd;
    console.log("new");
    playerToAdd = new Player(data.id, data.color);
    playerToAdd.initialize();
    return players.push(playerToAdd);
  });

  socket.on('myPlayer', function(data) {
    console.log("myPlayer");
    myPlayer = new Player(data.myPlayer.id, data.myPlayer.color);
    preparePlayground(data.map);
    map = data.map;
    myPlayer.initialize();
    return players.push(myPlayer);
  });

  socket.on('bombDroped', function(data) {
    console.log('bombDroped');
    return new Bomb(data.coordinate);
  });

  socket.on('disconnect', function(id) {
    var playerToErase, _i, _len, _ref;
    _ref = players.filter(function(element) {
      return element.id === id;
    });
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      playerToErase = _ref[_i];
      playerToErase.drawing.remove();
    }
    return players = players.filter(function(element) {
      return element.id !== id;
    });
  });

}).call(this);
